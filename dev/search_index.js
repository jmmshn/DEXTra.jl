var documenterSearchIndex = {"docs":
[{"location":"api/#Automatically-Generated-Documentation","page":"API Documentation","title":"Automatically Generated Documentation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [DEXTra]\nOrder   = [:type, :function]\npages = [\"core.jl\",]","category":"page"},{"location":"api/#DEXTra.DEXGraph","page":"API Documentation","title":"DEXTra.DEXGraph","text":"DEXGraph\n\nA graph representation of a set of DEXs.  Although the \n\nFields\n\ngraph: The name of the blockchain this liquidity pool is on.\nnodes: A list of the unique node labels.\npositions: The position of a particular node in nodes list.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.LiquidityPool","page":"API Documentation","title":"DEXTra.LiquidityPool","text":"LiquidityPool\n\nA liquidity pool represents a single source of assets and can be thought of as the nodes in a graph. All trading must occur between liquidity pools.\n\nFields\n\nchain: The name of the blockchain this liquidity pool is on.\ncoin: The name of the coin\nliquidity: The amount of liquidity in the pool denominated it's own coin.\nname: Allows addtional identification options if there are multiple liquidity pools for the same coin on the same chain.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.Order","page":"API Documentation","title":"DEXTra.Order","text":"Order\n\nA tuple representing an order in the orderbook.\n\nFields\n\nβ: The index of the asset being bought.\nσ: The index of the asset being sold.\nx̄: The maximum buy amount.\nȳ: The maximum sell amount.\nπ: The maximum exchange rate (i.e. pβ/pσ ≤ π).\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.OrderBook","page":"API Documentation","title":"DEXTra.OrderBook","text":"OrderBook\n\nA stack of orders.\n\nFields\n\norders: A vector of orders.\nassets: A vector of asset names.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.TradingPair","page":"API Documentation","title":"DEXTra.TradingPair","text":"TradingPair\n\nA trading pair represents a pair of liquidity pools and the exchange function between these pools.\n\nnote: Note\nThe two pools should always be ordered alphabetically.\n\nFields\n\nprovider: The name of the service provider ex. Uniswap, Sushiswap, etc.\npool1: The first liquidity pool in the trading pair.\npool2: The second liquidity pool in the trading pair.\nfee: The fee charged for exchanges on this trading pair.\nexchange_func: The exchange function between the two pools.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.LimitBuyOrder-NTuple{4, Any}","page":"API Documentation","title":"DEXTra.LimitBuyOrder","text":"LimitBuyOrder\n\nA tuple representing a limit buy order in the orderbook.\n\nFields\n\nβ: The index of the asset being bought.\nσ: The index of the asset being sold.\nx̄: The maximum buy amount.\nπ: The maximum exchange rate (i.e. pβ/pσ ≤ π).\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.LimitSellOrder-NTuple{4, Any}","page":"API Documentation","title":"DEXTra.LimitSellOrder","text":"LimitSellOrder\n\nA tuple representing a limit sell order in the orderbook.\n\nFields\n\nβ: The index of the asset being bought.\nσ: The index of the asset being sold.\nȳ: The maximum sell amount.\nπ: The maximum exchange rate (i.e. pβ/pσ ≤ π).\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.MarketBuyOrder-Tuple{Any, Any, Any}","page":"API Documentation","title":"DEXTra.MarketBuyOrder","text":"MarketBuyOrder\n\nA tuple representing a market buy order in the orderbook.\n\nFields\n\nβ: The index of the asset being bought.\nσ: The index of the asset being sold.\nx̄: The maximum buy amount.\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.MarketSellOrder-Tuple{Any, Any, Any}","page":"API Documentation","title":"DEXTra.MarketSellOrder","text":"MarketSellOrder\n\nA tuple representing a market sell order in the orderbook.\n\nFields\n\nβ: The index of the asset being bought.\nσ: The index of the asset being sold.\nȳ: The maximum sell amount.\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.get_level_graph-Tuple{DEXGraph, String}","page":"API Documentation","title":"DEXTra.get_level_graph","text":"get_level_graph(dex_graph::DEXGraph, source::String, sink::String)\n\nObtain a level graph from a DEXGraph object\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.get_univariate-Tuple{Array{TradingPair}}","page":"API Documentation","title":"DEXTra.get_univariate","text":"get_univariate(tps::Array{TradingPair}; directions::Array{Symbol})::Function\n\nCompose multiple univariate exchange functions into a single function.\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.get_univariate-Tuple{TradingPair}","page":"API Documentation","title":"DEXTra.get_univariate","text":"get_univariate(tp::TradingPair; direction::Symbol)::Function\n\nReturn the univariate exchange function for a given trading pair, using the current liquidity values.\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.total_trade_volume-Union{Tuple{T}, Tuple{OrderBook, Vector{T}, Vector{T}, Vector{T}}} where T<:Real","page":"API Documentation","title":"DEXTra.total_trade_volume","text":"total_trade_volume(orderbook::Orderbook, buy_volumes::Vector{Float64}, sell_volumes::Vector{Float64}, prices::Vector{Float64})\n\nCompute the total trade volume of an orderbook given the buy and sell volumes and prices of each asset.\n\nArguments\n\norderbook: The orderbook.\nbuy_volumes: A vector of buy volumes for each asset.\nsell_volumes: A vector of sell volumes for each asset.\nprices: A vector of representing all the prices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.rem_vertex!-Tuple{DEXGraph, String}","page":"API Documentation","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(dex_graph::DEXGraph, vertex::String)\n\nRemove a vertex by the name of the node and re-index the nodes and positions fields.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [DEXTra.ExchangeFunctions]\nOrder   = [:function]","category":"page"},{"location":"api/#DEXTra.ExchangeFunctions.constant_product-NTuple{4, Real}","page":"API Documentation","title":"DEXTra.ExchangeFunctions.constant_product","text":"constant_product(δ::Real, γ::Real, R₁::Real, R₂::Real)::Real\n\nThe exchange function for a constant-product market maker (CPMM)\n\n\n\n\n\n","category":"method"},{"location":"#DEXTra.jl","page":"Home","title":"DEXTra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"DEXTra.jl is a Julia package for routing and optimizing asset transfers on realistic networks of decentralized exchanges (DEXs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package is still under development and the API is subject to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since each DEX has an independent calculation of slippage and fees, an exact solution for the optimal route is likely to be intractable. Instead, we use a heuristic approach to find a good solution in a reasonable amount of time.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our code combines two methods for optimizing asset transfers on DEXs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A coincidence of wants algorithm resolves all the required transfers on a single block.  This is often the most cost-effective solution since it avoids the fees and slippage incurred by routing through one or more DEXs.\nAn optimization algorithm that considers the price impact of different pathways through the network and reports the best combination of paths to minimize the total cost of the transfer.  Note that due to increased slippage observed for large transfers, it is often advantageous to split a large transfer along multiple trading paths.","category":"page"},{"location":"#Terminology","page":"Home","title":"Terminology","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DEX: A decentralized exchange is a protocol that allows users to trade assets without a central counterparty.  The most popular DEXs are Uniswap, Sushiswap, and Balancer.\nLiquidity Pool: A liquidity pool is a collection of some cryptocurrency that is tendered to a DEX to facilitate trading.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In principle, there is a shared liquidity pool for all assets of one type (e.g. all ETH).   In practice, some DEXs may have multiple liquidity pools for each asset pair (e.g. ETH/USDC). We will use both of these definitions in our code depending on what we are trying to do.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coincidence of Wants: A coincidence of wants is a situation where two users have assets that they want to trade with each other.  In this case, the two users can trade directly with each other without routing through a DEX.","category":"page"},{"location":"#Development-Plans","page":"Home","title":"Development Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Level graph -> weighted graph -> optimizer pipeline\n[ ] Standardize output API\n[ ] COW algorithm\n[ ] Reading DEX data from Mongodb.\n[ ] Notebook tutorials a la JuliaGraphsTutorials.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DEXTra.jl is developed and maintained by Jimmy-Xuan Shen (@jmmshn)  with contributions by:     - Jesper T. Kristensen     - Juan Pablo Madrigal Cianci     - Giorgos Felekis","category":"page"}]
}
