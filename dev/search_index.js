var documenterSearchIndex = {"docs":
[{"location":"api/#Automatically-Generated-Documentation","page":"API Documentation","title":"Automatically Generated Documentation","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [DEXTra]\nOrder   = [:type, :function]\npages = [\"core.jl\", \"exchange_funcs.jl\"]","category":"page"},{"location":"api/#DEXTra.LiquidityPool","page":"API Documentation","title":"DEXTra.LiquidityPool","text":"LiquidityPool\n\nA liquidity pool represents a single source of assets. All trading occurs between liquidity pools.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.TradingPair","page":"API Documentation","title":"DEXTra.TradingPair","text":"TradingPair\n\nA trading pair represents a pair of liquidity pools and the exchange function between these pools.\n\nNote: The two pools should always be ordered alphabetically.\n\n\n\n\n\n","category":"type"},{"location":"api/#DEXTra.get_univariate-Tuple{Array{DEXTra.TradingPair}}","page":"API Documentation","title":"DEXTra.get_univariate","text":"get_univariate(tps::Array{TradingPair}; directions::Array{Symbol})::Function\n\nCompose multiple univariate exchange functions into a single function.\n\n\n\n\n\n","category":"method"},{"location":"api/#DEXTra.get_univariate-Tuple{DEXTra.TradingPair}","page":"API Documentation","title":"DEXTra.get_univariate","text":"get_univariate(tp::TradingPair; direction::Symbol)::Function\n\nReturn the univariate exchange function for a given trading pair, using the current liquidity values.\n\n\n\n\n\n","category":"method"},{"location":"#DEXTra.jl","page":"Home","title":"DEXTra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DEXTra.jl is a Julia package for routing and optimizing asset transfers on realistic networks of decentralized exchanges (DEXs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package is still under development and the API is subject to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since each DEX has an independent calculation of slippage and fees, an exact solution for the optimal route is likely to be intractable. Instead, we use a heuristic approach to find a good solution in a reasonable amount of time. Our code combines two methods for optimizing asset transfers on DEXs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A coincidence of wants algorithm resolves all the required transfers on a single block.  This is often the most cost-effective solution since it avoids the fees and slippage incurred by routing through one or more DEXs.\nAn optimization algorithm that considers the price impact of different pathways through the network and reports the best combination of paths to minimize the total cost of the transfer.  Note that due to increased slippage observed for large transfers, it is often advantageous to split a large transfer along multiple trading paths.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DEXTra.jl is developed by Dr. Jimmy-Xuan Shen (@jmmshn).","category":"page"}]
}
